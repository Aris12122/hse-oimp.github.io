#Ассоциативные контейнеры



##Итерация по контейнерам

Напоминаем, что есть несколько способа проитерироваться по контейнерам:
1) завести индекс, а после инкрементировать/декрементировать его
```
    for (size_t i = 0; i < number.size(); ++i) {
        if (number[i] % 2) {
            number[i] *= 2;
        }
        std::cout << number[i] << std::endl;
    }
```
2) Завести итератор, а после инкрементировать/декрементировать его в for
```
    for (auto it = numbers.begin(); it != numbers.end(); ++it) {
        if (*it % 2) {
            *it *= 2;
        }
        std::cout << *it << std::endl;
    }
```
3) range-based for
```
    for (auto& number : numbers) {
        if (number % 2) {
            number *= 2;
        }
        std::cout << number << std::endl;
    }
```
В чем различия: 
1) В некоторых ситуациях  у нас будут повторятся одинаковые куски кода (a[i]), что нарушает правило "don't repeat yourself"
2) Можно перепутать данный итератор с другим, но в целом код уже более читаемым
3) Код лишен недостатков выше, мы можем работать уже с данным элементом. Код эквивалентен второму варианту, если обозначить \text{auto\& i = *it}. Получается, что мы можем позвать range-based-for от любого объекта, у которого есть методы begin() и end(), которые возвращают "итератор" (есть * и инкрементирование).
К сожалению, для более универсального кода, работающего с любым контейнером, придется использовать только второй или третий вариант (т.к. может не быть оператора []).
 Если хотите использовать контейнер с произвольным доступом, то лучше использовать 2-ой вариант.

Функция std::advance() перемещает итератор, передаваемый ей в качестве аргумента. При этом смещение может производиться в прямом (или обратном) направлении сразу на несколько элементов: 

```
void std::advance (InputIterator& pos, Dist n)
```

##Ассоциативные контейнеры



\end{document}