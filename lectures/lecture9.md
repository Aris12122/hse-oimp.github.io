# RAII, move семантика, конструкторы копирования и операторы присваивания, умные указатели, исключения

## Конструкторы копирования и операторы присваивания

Предположим, что мы хотим сделать класс Array, у которого будет следующая реализация:
```
class Array {
public:
  ...
private:
    int* data = nullptr;
    size_t size = 0;
};
```
Мы хотим сделать возможным копирование объекта. Сделать это можно двумя путями. Первый путь - положиться на обычный конструктор копирования и ничего не писать. Тогда он 
просто скопирует все поля класса(shallow copy), и если мы вызовем у одного объекта деструктор, то второй будет указывать на пустую область памяти и может получиться undefined behavior.
Второй - реализовать свой конструктор копирования(deep copy):
```
Array(const Array& array) {
    this->size = array.size;
    this->data = new int[size]();
    std::copy(array.data, array.data + array.size, data);   // копирует массив array.data в data
}
```
Конструктор копирования вызывается когда мы пишем код в таком стиле:
```
Array array2 = array1;
Array array2(array1);
array2 = array1;          // Здесь не вызывается конструктор копирования
```
В последнем случае нужно реализовать оператор присваивания:
```
Array& operator=(const Array& array) {
    if (this == &array) {                 // проверка на то, что объект не равен себе. Нужна для случаев, когда мы хотим сделать array1 = array1
        return this*;
    }
    this->size = array.size;
    this->data = new int[size]();
    std::copy(array.data, array.data + array.size, data);
}
```

